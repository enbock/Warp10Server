/*
* NetworkConnection
*
*  Created on: 17.07.2011
*      Author: Endre Bock
*/

#ifndef NETWORKCONNECTION_
#define NETWORKCONNECTION_

#include <RoomOwner>
#include <Socket>
#include <NetworkDecoder>
#include <ByteArray>

namespace u
{
#define NETWORK_CONNECT_DEFAULT_TIMEOUT 10000 // 10 sec

	/**
	* The etablished network connection.
	* <p>This class object represent a etablished network connection. For
	* one connection exists two connection object(each per side).<br>
	* A decoder plugin translate the datablocks to the low level socket
	* data. The transfer between the connection and program object will
	* applied via datablocks. The type of the datablock is defined
	* by the used decoder.<br>
	* A networK connection can't work without a decoder. The network
	* decoder is exclusivly for the connection and will destroyed when the
	* connection object destroyed too.<br>
	* This abstract class implements many of the standard network protocol
	* routiens. Special implementation need to be implement in the subclasses
	* like <code>NetworkStandardConnection</code> or
	* <code>NetworkHTTPConnection</code>.
	* </p>
	*/
	class NetworkConnection : public RoomOwner
	{
		protected:
			friend class NetworkDecoder;

			/**
			* Connected socket.
			*/
			Socket *_socket;

			/**
			* Decoder to transform data between socket and datablocks.
			*/
			NetworkDecoder* _decoder;

			/**
			 * Flag: connection in close progress or closed.
			 */
			bool _isClose;

		public:
			/**
			 * The current timeout in milliseconds.
			 * 1000 = 1 second
			 */
			uint64 timeout;

			/**
			* Constructor of the network connection object.
			* <p>The constructor also setup the decoder plugin.
			* </p>
			* @param socket Connection socket object.
			* @param plugin Decoder object.
			*/
			NetworkConnection(Socket* socket, NetworkDecoder *plugin);
			/**
			* Destructor.
			* <p>Destroys also the decoder plugin and the socket.</p>
			*/
			~NetworkConnection();

			/**
			* Default destroyer.
			*/
			virtual void destroy() = 0;

			/**
			* Pointer to the socket object.
			* @return The socket object pointer.
			*/
			//Socket* socket();

			/**
			* Socket adress.
			* @return The address information from the socket.
			*/
			virtual String address();

			/**
			* Socket connected port.
			* <p><b>Note:</b> The port is not always used.</p>
			* @return The number of the port.
			*/
			virtual int64 port();

			/**
			 * Return the name of this class.
			 *
			 * @return Classname.
			 */
			String className();

			/**
			 * Send signal for a etablished connection.
			 */
			virtual void doReady() = 0;

			/**
			* Close begin procedure was received.
			* <p>This function send the <code>CLOSE_REQUIRED</code> signal to the
			* room. Also set the function the connection into the "inclode"
			* status.</p>
			*/
			virtual void doCloseRequired() = 0;

			/**
			* Close confirmation received.
			* <p>After the close confirmation from the other side was received,
			*	and a <code>CLOSED</code> signal inform all room members, that the
			*	room will not more exists. A removing of the signal listener is not
			*	necessary and perhaps produce out of memory errors.
			* </p>
			*/
			virtual void doClosed();

			/**
			* Transfer begin signal received[2].
			* <p>The connection received a data init package and informs
			* with the <code>INIT</code> signal the project about it. The project
			* can now prepare(eg. module loading/creating) the receiving of the
			* data and answers with a <code>READY</code> signal. The <code>id</code>
			* data contains the transfer code. This code has on all follow
			* signal to be set in the <code>id</code> attribute.
			* </p>
			* @param id Transfer-id.
			*/
			virtual void doTransferInit(uint64 id) = 0;

			/**
			* Transfer ready package was received[4].
			* <p>The other side is ready to receive the data. This function
			* send a <code>READY</code> signal to the project, that now the
			* transfer can be start. The project has to answer with a
			* <code>NetTransferEvent::DATA</code> signal.
			* </p>
			* @param id Transfer-id.
			*/
			virtual void doTransfer(uint64 id) = 0;

			/**
			* A datablock was received[7].
			* <p>The connection received a datablock from the other side. Via a
			* <code>NetTransferEvent::DATA</code> informs this function the
			* project about it.<br>
			* The <code>id</code> attribute contains the transfer code.
			* </p>
			 * @param id Transfer-id.
			 * @param data Received data.
			*/
			virtual void doReceivedData(uint64 id, ByteArray* data) = 0;

			/**
			* End of transfer received[11].
			* <p>The connection receive the EOT package. After all datablocks
			* was copied to the project close the connection this transfer.<br>
			* A <code>EOT</code> will be sent to inform the project about this.
			* </p>
			 * @param id Transfer-id.
			*/
			virtual void doEOT(uint64 id) = 0;

			/**
			 * Flag: Connection is in closing progress.
			 */
			bool isClose();

		protected:
			/**
			* Event API: Begin of the connection close procedure.
			* <p>With this signal change the connection to the "inclose"
			* status. This means, that new transfer requests will ignored.<br>
			* Also send this function the close package to inform the other side.</p>
			* @param signal Event object.
			*/
			virtual void onClose(Object* signal);

			/**
			* Event API: Close is confirmed.
			* <p>With the signal <code>CLOSE_CONFIRMED</code> signalize the project
			* or program that the connection can closed now. After sending of
			* the confirmation package close and destroy this function the
			* connection object. A <code>CLOSED</code> signal informs all room
			* member, that the room will not more exists after receiving this signal.
			* A remove signal listener is not necessary and can produce out of
			* memory errors.</p>
			* @param signal Event object.
			*/
			virtual void onCloseConfirmed(Object* signal) = 0;

			/**
			* Event API: Data transfer initialized[1].
			* <p>Via the <code>INIT</code> signal tell the program/project the
			* connection, that data(block) for sending exists.<br>
			* This function send a data init package and a transfer code
			* to the other side.
			* </p>
			* @param signal The INIT signal object.
			*/
			virtual void onTransferInit(Object *signal) = 0;

			/**
			* Event API: Ready for receiving of data[3].
			* <p>This function informs the other side with a ready package, that
			* this side is ready to receive the data.
			* </p>
			*/
			virtual void onTransferReady(Object *signal) = 0;

			/**
			* Event API: Ready for sending of data[5].
			* <p>Via the <code>NetTransferEvent::DATA</code> signal starts the
			* project the data transfer. Via <code>DataTransferEvent::GET</code> ask
			* the connection active for the complete existing data(block). That signal
			* will sent by this function.
			* </p>
			* @param signal The DATA signal object.
			*/
			virtual void onSendDataRequest(Object *signal) = 0;

			/**
			* Event API: Data transport[6].
			* <p>The project sent the data via this signal. The decoder plugin
			* encode the data for the target network and send the data on the
			* socket.<br>
			* The <code>data</code> attribute contains the pointer to the data
			* and the <code>id</code> contains the transfer code.<br>
			* After complete sending of the data send this function a <code>
			* COMPLETE</code> signal. The project can with receiving of that
			* signal clean the databugger and can start the next data
			* block with <code>NetTransferEvent::DATA</code> or finishing the
			* transfer with <code>NetTransferEvent::EOT</code>.
			* </p>
			* @param signal The DATA signal with the data.
			*/
			virtual void onSendData(Object *signal) = 0;

			/**
			* Event API: Get the received data[8].
			* <p>The project informs the connection with this <code>GET</code> signal
			* that the datablock can now copied. This do this function with the
			* <code>DataTransferEvent::DATA</code> signal. The project has the
			* receiving and saving activity to confirm with <code>COMPLETE</code>.
			* </p>
			*/
			virtual void onGetDataRequest(Object *signal) = 0;

			/**
			* Event API: Complete saved[9].
			* <p>This function remove the datablock, which was sent to the project
			* and cleanup the memory. If more received datablock or eot packages
			* exists, then call this the function the <code>doReceiveData()</code>
			* or <code>doEOT()</code> function.<br>
			* The <code>id</code> attribute contains the transfer code.
			* </p>
			* @param signal The COMPLET signal object with the transfer code.
			*/
			virtual void onDataComplete(Object signal) = 0;

			/**
			* Event API: End of transaction[10].
			* <p>Over the <code>EOT</code> signal tells the project the connection
			* that the end of the data transfer reached. The connection sent a
			* eot package to the other side and close the transfer after it. The
			* transfer id from the <code>id</code> attribute will not more used,
			* unless the maximum number if id's was reached.
			* </p>
			* @param signal The EOT signal object.
			*/
			virtual void onEOT(Object *signal) = 0;

	};
}

#endif /* NETWORKCONNECTION_ */
